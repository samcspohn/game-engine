#version 430 core

#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_storage_buffer_object : enable


struct _transform {
	vec3 position; int id;
	vec3 scale; int parent;
	vec4 rotation;
	int childrenBegin;
	int childrenEnd;
	int prevSibling;
	int nextSibling;
};
struct particle{
    vec3 position;
    uint emitter;
    vec3 scale;
    uint emitter_prototype;
    vec4 rotation;

    vec3 velocity;
    int live;

    float life;
    int next;
    int prev;
    float p;
};
struct emitter_prototype{
    float emission_rate;
    float lifetime;
    float rotation_rate;
    int id;

    vec4 color;

    vec3 velocity;
    int live;

    vec3 scale;
    int billboard;

    int trail;
    vec3 p;
};
struct emitter{
    uint transform;
    uint emitter_prototype;
    float emission;
    int live;

    int last_particle;
    vec3 p;
};
layout(std430,binding = 0) buffer t{_transform transforms[];};
layout(std430,binding = 2) buffer p{particle particles[];};
layout(std430,binding = 3) buffer ep{emitter_prototype prototypes[];};
layout(std430,binding = 4) buffer e{emitter emitters[];};
layout(std430,binding = 5) buffer r{uint rng[];};
layout(std430,binding = 6) buffer d{uint dead[];};
layout(std430,binding = 1) buffer ac{uint atomicCounters[];};

const uint liveParticles = 0;
const uint destroyCounter = 1;
uniform uint count;
uniform float deltaTime;
uniform float time;
uniform uint max_particles;
uniform uint stage;
uniform vec3 cameraPosition;
uniform vec3 cameraUp;

float PHI = 1.61803398874989484820459;  // Î¦ = Golden Ratio   
float rand(in vec2 xy, in float seed){
    xy += vec2(1);
    return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);
}

mat4 translate(mat4 m, vec3 translation){
		mat4 t = {{1,0,0,translation.x},
		{0,1,0,translation.y,},
		{0,0,1,translation.z}
		,{0,0,0,1}};
		return m * transpose(t);
}
mat4 scale(mat4 m, vec3 scale){
	mat4 s = {{scale.x,0,0,0}, {0,scale.y,0,0},{0,0,scale.z,0},{0,0,0,1}};
	return m * transpose(s);
}

mat4 rotate(mat4 m, vec4 q){
	mat4 r1 = {{q.w,q.z,-q.y,q.x},{-q.z,q.w,q.x,q.y},{q.y,-q.x,q.w,q.z},{-q.x,-q.y,-q.z,q.w}};
	mat4 r2 = {{q.w,q.z,-q.y,-q.x},{-q.z,q.w,q.x,-q.y},{q.y,-q.x,q.w,-q.z},{q.x,q.y,q.z,q.w}};
	return m * r1 * r2;
}

mat4 identity(){
	mat4 i = {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}};
	return i;
}
vec4 lookAt(in vec3 lookAt, in vec3 upDirection) {
vec3 forward = lookAt; vec3 up = upDirection;
forward = normalize(forward);
vec3 right = normalize(cross(up, forward));
up = normalize(cross(forward,right));

#define m00 right.x
#define m01 up.x
#define m02 forward.x
#define m10 right.y
#define m11 up.y
#define m12 forward.y
#define m20 right.z
#define m21 up.z
#define m22 forward.z

vec4 ret;
ret.w = sqrt(1.0f + m00 + m11 + m22) * 0.5f;
float w4_recip = 1.0f / (4.0f * ret.w);
ret.x = (m21 - m12) * w4_recip;
ret.y = (m02 - m20) * w4_recip;
ret.z = (m10 - m01) * w4_recip;

#undef m00
#undef m01
#undef m02
#undef m10
#undef m11
#undef m12
#undef m20
#undef m21
#undef m22

return ret;
}

void begin(uint thread_id){
    // live[0] = 1;
    
    emitter e = emitters[thread_id];
    if(e.live == 1){

        emitter_prototype ep = prototypes[e.emitter_prototype];
        uint emission = uint(e.emission);
        uint new_particles_start = atomicAdd(atomicCounters[liveParticles],emission);
        atomicMin(atomicCounters[liveParticles],max_particles);
        uint end = new_particles_start + emission;
        
        for(uint i = new_particles_start; i < end && i < max_particles; ++i){
            int x = int(dead[i]);
            particle p;
            p.position = transforms[e.transform].position;
            vec2 id = vec2(thread_id % max_particles, thread_id / max_particles);
            p.rotation = normalize(vec4(rand(id,time + 3) - 0.5f,
            rand(id,time + 4) - 0.5f,
            rand(id,time + 5) - 0.5f,
            rand(id,time + 6) - 0.5f
            ));
            // p.rotation  = transforms[e.transform].rotation;
            p.scale = transforms[e.transform].scale * ep.scale;
            p.life = 1.f;
            p.emitter = thread_id;
            p.emitter_prototype = e.emitter_prototype;
            vec3 random = vec3(
            rand(id,time) - 0.5f,
            rand(id,time + 1) - 0.5f,
            rand(id,time + 2) - 0.5f);
            p.velocity = vec3(rotate(identity(),transforms[e.transform].rotation) * vec4(random * ep.velocity * transforms[e.transform].scale,1));
            
            // set trail
            if(ep.trail == 1){
                if(e.last_particle != -1){
                    particles[e.last_particle].next = int(x);
                }
                p.next = -int(thread_id) - 2;
                p.prev = e.last_particle;
                e.last_particle = int(x);
            }

            p.live = 1;
            particles[x] = p;
        }
        // emitters[thread_id] = e;
    }
}

void update(uint id){

    if(particles[id].live == 1){
        particle p = particles[id];
        emitter_prototype proto = prototypes[p.emitter_prototype];
        p.position += p.velocity * deltaTime;
        p.life -= deltaTime / prototypes[p.emitter_prototype].lifetime;

        if(proto.billboard == 1)
            p.rotation = lookAt(cameraPosition - p.position,cameraUp);
        if(p.life < 0)
        {
            uint index = atomicAdd(atomicCounters[liveParticles],-1);
            dead[index - 1] = id;
            p.live = 0;
            p.next = p.prev = -1;
        }
        particles[id] = p;
    }
}

// void cleanup(uint thread_id){

//     uint liveMoved = atomicAdd(atomicCounters[liveParticles],-1);
//     uint toDestroyIndex = atomicAdd(atomicCounters[destroyCounter],-1);
//     // live[toDestroy[thread_id]] = particles[liveMoved];
//     dead[liveMoved - 1] = live[toDestroy[toDestroyIndex - 1]];
//     live[toDestroy[toDestroyIndex - 1]] = live[liveMoved - 1];
// }

layout( local_size_x = 64,  local_size_y = 1, local_size_z = 1) in;
void main () {
    uint gid = gl_GlobalInvocationID.x;
        if( stage == 0 && gid < count) // only emitters
            begin(gid);
        if(stage == 1 && gid < max_particles)
            update(gid);


}