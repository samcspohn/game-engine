#version 430 core

#include "particle.glsl"

struct d{
    uint key;
    uint id;
};


layout(std430,binding = 0) buffer c{uint counts[];}; //5? long
layout(std430,binding = 1) buffer o{uint offsets[];}; //5? long
layout(std430,binding = 2) buffer d_{d data1[];};
layout(std430,binding = 6) buffer d__{d data2[];};
layout(std430,binding = 4) buffer p{particle particles[];};
layout(std430,binding = 5) buffer a{uint atomics[];};

layout(std430,binding = 7) buffer i{uint init[];}; // num threads
layout(std430,binding = 8) buffer i2{d init2[];}; // num particles
layout(std430,binding = 9) buffer i3{uint localCount[];}; // num threads

uniform int stage;
uniform mat4 vp;
uniform uint count;
uniform uint max_particles;

layout( local_size_x = 64,  local_size_y = 1, local_size_z = 1) in;
void main () {
    uint gid = gl_GlobalInvocationID.x;
    uint index;
    if(gid > count)
        return;
    if(stage == -1){
        uint start = max_particles / count * gid;
        uint end = max_particles / count * (gid + 1);
        uint countParticles = 0;
        for(uint a = start; a < end; a++){
            float z = (vp * vec4(particles[a].position,1)).z;
            if(z > 0 && particles[a].live == 1){
                index = countParticles++;
                init2[start + index].key = floatBitsToUint(z);
                init2[start + index].id = a;
            }
        }
        init[gid] = countParticles;
        localCount[gid] = countParticles;
        if(atomicAdd(atomics[0],1) == count - 1){
            uint temp = init[0];
            uint temp2 = 0;
            init[0] = 0;
            for(uint a = 1; a < count; a++){
                temp2 = init[a];
                init[a] = temp;
                temp += temp2;
            }
            atomics[0] = temp;
        }
    }
    else if(stage == -2){
        uint start = max_particles / count * gid;
        uint end = start + localCount[gid];
        uint _index = init[gid];
        for(uint a = start; a < end; a++){
            data1[_index].key = init2[a].key;
            data1[_index++].id = init2[a].id;
        }
    }

    // first pass
    else if(stage == 0){
        index = data1[gid].key & 0x0000ffff;
        atomicAdd(counts[index],1);
    }
    else if(gid == 0 && stage == 1){
        offsets[0] = 0;
        for(int i = 1; i < 65536; i++){
            offsets[i] = offsets[i - 1] + counts[i - 1];
        }
    }else if(stage == 2){
        index = data1[gid].key & 0x0000ffff;
        data2[atomicAdd(offsets[index],1)] = data1[gid];
    }

    // second pass
    else if(stage == 3){
        index = data2[gid].key >> 16;
        atomicAdd(counts[index],1);
    }
    else if(gid == 0 && stage == 4){
        offsets[0] = 0;
        for(int i = 1; i < 65536; i++){
            offsets[i] = offsets[i - 1] + counts[i - 1];
        }
    }else if(stage == 5){
        index = data2[gid].key >> 16;
        data1[atomicAdd(offsets[index],1)] = data2[gid];
    }
}




















/////////////////////////// fastest


#version 430 core

#include "particle.glsl"

struct d{
    uint key;
    uint id;
};


layout(std430,binding = 0) buffer c{uint counts[];}; //5? long
layout(std430,binding = 1) buffer o{uint offsets[];}; //5? long
layout(std430,binding = 2) buffer d_{d data1[];};
layout(std430,binding = 6) buffer d__{d data2[];};
layout(std430,binding = 4) buffer p{particle particles[];};
layout(std430,binding = 5) buffer a{uint atomics[];};

uniform int stage;
uniform mat4 vp;
uniform uint count;

layout( local_size_x = 64,  local_size_y = 1, local_size_z = 1) in;
void main () {
    uint gid = gl_GlobalInvocationID.x;
    uint index;
    if(gid > count)
        return;
    if(stage == -1 && particles[gid].live == 1){
        float z = (vp * vec4(particles[gid].position,1)).z;
        if(z > 0){
            index = atomicAdd(atomics[0],1);
            data1[index].key = floatBitsToUint(z);
            data1[index].id = gid;
        }
    }

    // first pass
    else if(stage == 0){
        index = data1[gid].key & 0x0000ffff;
        atomicAdd(counts[index],1);
    }
    else if(gid == 0 && stage == 1){
        offsets[0] = 0;
        for(int i = 1; i < 65536; i++){
            offsets[i] = offsets[i - 1] + counts[i - 1];
        }
    }else if(stage == 2){
        index = data1[gid].key & 0x0000ffff;
        data2[atomicAdd(offsets[index],1)] = data1[gid];
    }

    // second pass
    else if(stage == 3){
        index = data2[gid].key >> 16;
        atomicAdd(counts[index],1);
    }
    else if(gid == 0 && stage == 4){
        offsets[0] = 0;
        for(int i = 1; i < 65536; i++){
            offsets[i] = offsets[i - 1] + counts[i - 1];
        }
    }else if(stage == 5){
        index = data2[gid].key >> 16;
        data1[atomicAdd(offsets[index],1)] = data2[gid];
    }
}