#version 430 core
#include "../util.glsl"
#include "../transform.glsl"
#include "particle.glsl"



const uint WG_SIZE = 128;
const uint N_GROUPS = 256;
const uint RADIX = 12;
const uint BUCK = 1 << RADIX;

const uint block_sum_size = 256;



layout(std430,binding = 0) buffer lp{uint livingParticles[];};
layout(std430,binding = 1) buffer d_in{d _input[];};
layout(std430,binding = 2) buffer d_out{d _output[];};

layout(std430,binding = 4) buffer p{particle particles[];};
layout(std430,binding = 5) buffer a{uint atomics[];};

// layout(std430,binding = 7) buffer d_h{uint histo[];};
layout(std430,binding = 8) buffer ep{emitter_prototype prototypes[];};


layout(std430,binding = 9) buffer e{emitter emitters[];};//
layout(std430,binding = 10) buffer t{_transform transforms[];};//

// layout(std430,binding = 10) buffer ko{uint keys_out[];};



uniform int stage;
uniform uint count;
uniform uint nkeys;
uniform uint pass;
uniform float x_size;
uniform float y_size;
uniform vec3 camp;
uniform vec3 camPos;
uniform vec3 cameraForward;
uniform vec3 cameraUp;
uniform mat3 camInv;
uint convertFloatToClamped(float f){
    return uint(f * 32768 + 32768);
}

layout( local_size_x = 256,  local_size_y = 1, local_size_z = 1) in;
void main () {
    uint gid = gl_GlobalInvocationID.x;
    uint index;
    if(gid < count){
        switch(stage){
            // case -2:
            //     histo[gid] = 0;
            //     break;
            case -1:
                {
                    uint id = livingParticles[gid];
                    particle p = particles[id];
                    emitter_prototype proto = prototypes[p.emitter_prototype];
                    vec3 position = p.position;
                    vec3 position2 = position;
                    if(p.next == -1){
                        position2 = position;
                    }
                    else if(p.next < -1){
                        if(emitters[-p.next - 2].last == id){
                            position2 = transforms[emitters[-p.next - 2].transform].position;
                        }
                    }else{
                        position2 = particles[p.next].position;
                    }
                    vec3 p1 = camInv * (position - camp);
                    vec3 p2 = camInv * (position2 - camp);
                    vec3 p3 = (p1 + p2) / 2;
                    float width = prototypes[p.emitter_prototype].sizeLife[int((1.f - min(max(p.life,0.01f),1.f)) * 100.f)] * length(p.scale.xy);
                    float radius = length(p2 - p3) / 2 + width;
                    if(p.life > 0 && p3.z - radius < 0.f
                    && (abs(p3.x) - radius) / abs(p3.z) < x_size
                    && (abs(p3.y) - radius) / abs(p3.z) < y_size){// && radius < 100 *  width
                        // && (abs(p3.x) - radius) / abs(p3.z) < 1.f && (abs(p3.y) - radius) / abs(p3.z) < 1.f){
                        index = atomicAdd(atomics[0],1);
                        // renderParticles[index] = gid;
                        d item;
                        // uint _key =  (~floatBitsToUint(p1.z) << 1) >> 16;
                        // key(item, _key);
                        // keys_out[index] = _key;
                        // emitterID(item, p.emitter);
                        life(item, p.life);
                        protoID(item, p.emitter_prototype);
                        vec3 p11;
                        vec3 p21;
                        vec4 rot;
                        vec2 _scale;
                        rot = get(p.rotation);
                        if(prototypes[p.emitter_prototype].trail == 1){
                            p11 = position;
                            p21 = position2;
                            p11 = p11 + (p21 - p11) / 2;
                            _scale = vec2(p.scale.x, length(position - position2));
                        }else{
                            _scale = p.scale.xy;
                            p11 = position;
                        }
                        if(proto.billboard == 1)
                            rot = lookAt(-cameraForward, (cameraForward == vec3(0,0,1) || cameraForward == vec3(0,0,-1)) ? vec3(1,0,0) : cameraUp) * proto.billboard;
                        if(proto.trail == 1){
                            // p.rotation = lookAt(-cameraForward, (cameraForward == vec3(0,0,1) || cameraForward == vec3(0,0,-1)) ? vec3(1,0,0) : cameraUp);
                            vec3 y = position2 - position;
                            vec3 x = cross(y, position2 - camPos);
                            vec3 l = cross(x,y);
                            rot = lookAt(l,y);
                        }
                        p11 = camInv * (p11 - camPos);
                        setScale(item,_scale);
                        // genPosition1(item, p11);
                        smvec3 pos;
                        set(pos,p11);
                        setPos(item,pos);
                        // set(item.pos,p11);
                        // setRotation(item, rot);
                        set(item.rot,rot);
                        // genPosition2(item, p21);

                        // item.id = gid;
                        // atomicAdd(histo[item.z >> 16],1);
                        _input[index] = item;
                        // _output[index] = item;
                        // _input[index].id = gid;
                    }
                }
                break;
        }
    }
}