#version 430 core
#include "particle.glsl"

struct d{
    uint key;
    uint id;
};
const uint WG_SIZE = 128;
const uint N_GROUPS = 256;
const uint RADIX = 12;
const uint BUCK = 1 << RADIX;
const uint block_sum_size = uint(sqrt(N_GROUPS * BUCK));

// layout(std430,binding = 0) buffer c{uint counts[];}; //5? long
// layout(std430,binding = 1) buffer o{uint offsets[];}; //5? long
// layout(std430,binding = 2) buffer d_{d data1[];};
// layout(std430,binding = 6) buffer d__{d data2[];};
layout(std430,binding = 4) buffer p{particle particles[];};
layout(std430,binding = 5) buffer a{uint atomics[];};

uniform int stage;
uniform mat4 vp;
uniform uint count;
// uniform mat4 frustum;
uniform uint numElements;
uniform uint breadth;
//////////////////////////////////////////////////

layout(std430,binding = 1) buffer d_in{d _input[];};
layout(std430,binding = 2) buffer d_out{d _output[];};
layout(std430,binding = 3) buffer blk_sum{uint block_sums[];};
layout(std430,binding = 6) buffer d_s{uint scan[];};
layout(std430,binding = 7) buffer d_h{uint histo[];};

shared uint local_histo[BUCK];
// shared uint local_scan[BUCK*N_GROUPS];

uniform uint nkeys;
uniform uint pass;
uniform uint wg_size;
uniform uint offset;



void radix2(uint g_id){

    // __kernel void count(const __global int* _input,__global int* _output,__local int* local_histo,const int pass,const int nkeys)
    if(stage == 0)
    {
        uint i;
        // uint really_local_histo[BUCK];
        // for(i = 0; i < BUCK; i++){
        //     really_local_histo[i] = 0;
        // }
        uint bucks_size = (BUCK) / WG_SIZE;
        uint bucks_start = bucks_size * gl_LocalInvocationID.x;
        uint bucks_end = bucks_start + bucks_size;
        for(i = bucks_start; i < bucks_end; i++){
            local_histo[i] = 0;
        }

        barrier();
        // memoryBarrierShared();

        //Calculate elements to process per item
        uint size = nkeys / count;
        //Calculate where to start on the global array
        uint start = g_id * size + offset;
        uint end = start + size;
        if(g_id == count - 1){
            end = nkeys + offset;
        }
        
        for(i = start; i < end; i++) {
            uint key = _input[i].key;
            key = ((key >> (pass * RADIX - 4)) & (BUCK - 1));
            atomicAdd(local_histo[key],1);
        }
        // memoryBarrierShared();
        barrier();
        for(i = bucks_start; i < bucks_end; i++) {
            histo[i * N_GROUPS + gl_WorkGroupID.x] = local_histo[i];
        }
        // if(g_id == count - 1)
        // histo[0] = nkeys;
    }


    if(stage == 11){
        // if(g_id == 0){
            for(uint i = 0; i < 256; i++){
                uint start = i * 128;
                uint end = start + 128;
                
                uint temp = histo[start];
                histo[start] = 0;
                for(uint j = start + 1; j < end; j++){
                    uint temp2 = histo[j];histo[i * N_GROUPS + gl_WorkGroupID.x];
                    temp += temp2;
                }
                block_sums[i] = temp;
            }

            uint temp = block_sums[0];
            block_sums[0] = 0;
            for(uint i = 1; i < 256; i++){
                uint temp2 = block_sums[i];
                block_sums[i] = temp;
                temp += temp2;
            }

            // for(int i = 0; i < 256; i++){
            //     for(int j = 0; j < 128; j++){
            //         histo[i*128 + j] += block_sums[i];
            //     }
            // }
            for(int i = 0; i < 32768; i++){
                histo[i] += block_sums[i/128];
            }


            // uint temp = histo[0];
            // histo[0] = 0;
            // uint end = BUCK * 16 * 128;
            // for(uint i = 1; i < end; i++){
            //     uint temp2 = histo[i];
            //     histo[i] = temp;
            //     temp += temp2;
            // }
        // }
    }

    // scan kernel 2
    if(stage == 1){
        uint start = g_id * block_sum_size;
        uint end = start + block_sum_size;
        
        uint temp = histo[start];
        histo[start] = 0;
        for(uint i = start + 1; i < end; i++){
            uint temp2 = histo[i];
            histo[i] = temp;
            temp += temp2;
        }
        block_sums[g_id] = temp;
    }

    if(stage == 2){
        uint temp = block_sums[0];
        block_sums[0] = 0;
        for(uint i = 1; i < block_sum_size; i++){
            uint temp2 = block_sums[i];
            block_sums[i] = temp;
            temp += temp2;
        }
    }

    if(stage == 3){
        // uint group_id = gl_WorkGroupID.x;
        histo[g_id] += block_sums[g_id/block_sum_size];
    }



    /** REORDER KERNEL **/
    // __kernel void reorder(__global int* array, __global int* histo, __global int* _output, const int pass, const int nkeys, __local int* local_histo)
    if(stage == 4)
    {
        // uint g_id = gl_GlobalInvocationID.x;
        //Bring histo to local memory
        uint i;
        // uint really_local_histo[BUCK];
        // for(i = 0; i < BUCK; i++){
        //     really_local_histo[i] = histo[i * count + g_id];
        // }
        uint bucks_size = (BUCK) / WG_SIZE;
        uint bucks_start = bucks_size * gl_LocalInvocationID.x;
        uint bucks_end = bucks_start + bucks_size;
        for(i = bucks_start; i < bucks_end; i++) {
            local_histo[i] = histo[i * N_GROUPS + gl_WorkGroupID.x];
        }
        // memoryBarrierShared();
        
        barrier();
        // memoryBarrierShared();

        //Write to global memory in order
        uint size = nkeys / count;
        uint start = g_id * size  + offset;
        uint end = start + size;
        if(g_id == count - 1){
            end = nkeys + offset;
        }
        
        for(i = start; i < end; i++) {
                d item = _input[i];
                uint key = (item.key >> (pass * RADIX - 4)) & (BUCK - 1);
                // uint pos = local_histo[key * l_size + l_id];
                uint pos = atomicAdd(local_histo[key],1);
                // if(pass == 7)
                //     pos = nkeys - pos - 1;
                _output[pos + offset] = item;
                // _output[nkeys - i - 1] = item;
        }
        
    }
}



// void merge(uint id){
//     uint start = id * breadth;
//     uint end = start + breadth;
//     if(start > numElements)
//         return;
//     if(end > numElements)
//         end = numElements;
//     uint dst = start;
//     uint first = start;
//     uint secondStart = start + breadth / 2;
//     if(secondStart > end)
//         secondStart = end;
//     uint second = secondStart;

//     while(dst < end && first < secondStart && second < end){
//         if(data1[first].key > data1[second].key){
//             data2[dst] = data1[first];
//             first++;
//         }else{
//             data2[dst] = data1[second];
//             second++;
//         }
//         dst++;
//     }
//     for(;first < secondStart;first++){
//         data2[dst] = data1[first];
//         dst++;
//     }
//     for(;second < end;second++){
//         data2[dst] = data1[second];
//         dst++;
//     }
//     for(uint i = start; i < end;i++){
//         data1[i] = data2[i];
//     }
// }


// void radix(uint gid){
//     uint index;
//     // first pass
//     if(stage == 0){
//         index = data1[gid].key & 0x0000ffff;
//         atomicAdd(counts[index],1);
//     }
//     else if(gid == 0 && stage == 1){
//         offsets[0] = 0;
//         for(int i = 1; i < 65536; i++){
//             offsets[i] = offsets[i - 1] + counts[i - 1];
//         }
//     }else if(stage == 2){
//         index = data1[gid].key & 0x0000ffff;
//         data2[atomicAdd(offsets[index],1)] = data1[gid];
//     }

//     // second pass
//     else if(stage == 3){
//         index = data2[gid].key >> 16;
//         atomicAdd(counts[index],1);
//     }
//     else if(gid == 0 && stage == 4){
//         offsets[0] = 0;
//         for(int i = 1; i < 65536; i++){
//             offsets[i] = offsets[i - 1] + counts[i - 1];
//         }
//     }else if(stage == 5){
//         index = data2[gid].key >> 16;
//         data1[atomics[0] - atomicAdd(offsets[index],1)] = data2[gid];
//     }
// }


layout( local_size_x = 128,  local_size_y = 1, local_size_z = 1) in;
void main () {
    uint gid = gl_GlobalInvocationID.x;
    uint index;
    if(gid >= count)
        return;
    if(stage == -1){
        vec3 v = (vp * vec4(particles[gid].position,1)).xyz;
        if(v.z > 0 && abs(v.x / v.z) < 1.1 && abs(v.y / v.z) < 1.1 && particles[gid].live == 1){
            index = atomicAdd(atomics[0],1);
            d item;
            item.key =  ~floatBitsToUint(v.z) << 1;
            item.id = gid;
            _input[index] = item;
            // _input[index].id = gid;
        }
    }
    else{
        radix2(gid);
        // radix(gid);
        // merge(gid);
    }

}