#version 430 core

#include "particle.glsl"

struct d{
    uint key;
    uint id;
};


layout(std430,binding = 0) buffer c{uint counts[];}; //5? long
layout(std430,binding = 1) buffer o{uint offsets[];}; //5? long
layout(std430,binding = 2) buffer d_{d data1[];};
layout(std430,binding = 6) buffer d__{d data2[];};
layout(std430,binding = 4) buffer p{particle particles[];};
layout(std430,binding = 5) buffer a{uint atomics[];};

uniform int stage;
uniform mat4 vp;
uniform uint count;

layout( local_size_x = 64,  local_size_y = 1, local_size_z = 1) in;
void main () {
    uint gid = gl_GlobalInvocationID.x;
    uint index;
    if(gid > count)
        return;
    if(stage == -1 && particles[gid].live == 1){
        float z = (vp * vec4(particles[gid].position,1)).z;
        if(z > 0){
            index = atomicAdd(atomics[0],1);
            data1[index].key = floatBitsToUint(z);
            data1[index].id = gid;
        }
    }

    // first pass
    else if(stage == 0){
        index = data1[gid].key & 0x0000ffff;
        atomicAdd(counts[index],1);
    }
    else if(gid == 0 && stage == 1){
        offsets[0] = 0;
        for(int i = 1; i < 65536; i++){
            offsets[i] = offsets[i - 1] + counts[i - 1];
        }
    }else if(stage == 2){
        index = data1[gid].key & 0x0000ffff;
        data2[atomicAdd(offsets[index],1)] = data1[gid];
    }

    // second pass
    else if(stage == 3){
        index = data2[gid].key >> 16;
        atomicAdd(counts[index],1);
    }
    else if(gid == 0 && stage == 4){
        offsets[0] = 0;
        for(int i = 1; i < 65536; i++){
            offsets[i] = offsets[i - 1] + counts[i - 1];
        }
    }else if(stage == 5){
        index = data2[gid].key >> 16;
        data1[atomics[0] - atomicAdd(offsets[index],1)] = data2[gid];
    }
}