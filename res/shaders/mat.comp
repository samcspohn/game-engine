#version 430 core

#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_storage_buffer_object : enable
//#extension GL_NV_gpu_shader5 : enable

struct _transform {
	vec3 position; int id;
	vec3 scale; int parent;
	vec4 rotation;
	int childrenBegin;
	int childrenEnd;
	int prevSibling;
	int nextSibling;
};

struct __renderer {
	uint transform;
	uint id;
};
uniform uint num;
uniform vec3 camPos;
uniform vec3 camForward;
uniform mat4 view;
uniform mat4 vRot;
uniform mat4 projection;


#define vector(name, type ,_binding) layout(std430,binding = _binding) buffer _{uint size; type name[];}

//vector(transforms, _transform, 0);

layout(std430,binding = 0) buffer t{_transform transforms[];};
layout(std430,binding = 1) buffer r{__renderer renderers[];};
//layout(std430, binding = 2) buffer tid{uint tids[];};

struct matrix{
	mat4 mvp;
	mat4 model;
	mat4 normal;
};
layout(std430, binding = 3) buffer _m_buffs{
	matrix matrixes[];
};

mat4 translate(mat4 m, vec3 translation){
		mat4 t = {{1,0,0,translation.x},
		{0,1,0,translation.y,},
		{0,0,1,translation.z}
		,{0,0,0,1}};
		return m * transpose(t);
}
mat4 scale(mat4 m, vec3 scale){
	mat4 s = {{scale.x,0,0,0}, {0,scale.y,0,0},{0,0,scale.z,0},{0,0,0,1}};
	return m * transpose(s);
}

mat4 rotate(mat4 m, vec4 q){
	mat4 r1 = {{q.w,q.z,-q.y,q.x},{-q.z,q.w,q.x,q.y},{q.y,-q.x,q.w,q.z},{-q.x,-q.y,-q.z,q.w}};
	mat4 r2 = {{q.w,q.z,-q.y,-q.x},{-q.z,q.w,q.x,-q.y},{q.y,-q.x,q.w,-q.z},{q.x,q.y,q.z,q.w}};
	return m * r1 * r2;
}

mat4 identity(){
	mat4 i = {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}};
	return i;
}

bool planeIntersect(float plane[4], vec3 point) {
	return point.x*plane[0] + point.y * plane[1] + point.z * plane[2] + plane[3] < 0;
}


layout( local_size_x = 64,  local_size_y = 1, local_size_z = 1) in;
void main () {
	uint gid = gl_GlobalInvocationID.x;

	if(gid >= num)
		return;
	//plane
		float a, b, c, d;
		a = camForward.x;
		b = camForward.y;
		c = camForward.z;
		d = a * -camPos.x + b * -camPos.y + c * -camPos.z;
		float plane[] = { a,b,c,d };

	_transform transform = transforms[renderers[gid].transform];
//	uint renderid = renderers[gid].renderer;
	uint buffsid = renderers[gid].id;
//	if(planeIntersect(plane,transform.position + transform.scale * 2) && planeIntersect(plane,transform.position - transform.scale * 2))
//		matrixes[buffsid].visible = false;
//	else{
//		matrixes[buffsid].visible = true;

		matrixes[buffsid].model = translate(identity(),transform.position) * scale(identity(),transform.scale) * rotate(identity(),transform.rotation);
		matrixes[buffsid].mvp = projection * vRot * view * matrixes[buffsid].model;

		matrixes[buffsid].normal = mat4(transpose(inverse(mat3(rotate(identity(),transform.rotation)))));
//	}
}
