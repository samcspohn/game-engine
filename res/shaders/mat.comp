#version 430 core

#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_storage_buffer_object : enable
//#extension GL_NV_gpu_shader5 : enable

#include "transform.glsl"
#include "util.glsl"


#define vector(name, type ,_binding) layout(std430,binding = _binding) buffer _name{uint size; type name[];}

struct matrix{
	mat4 mvp;
	mat4 model;
	mat4 normal;
};
struct __renderer {
	uint transform;
	uint id;
};

layout(std430,binding = 0) buffer t{_transform transforms[];};
layout(std430,binding = 1) buffer r{__renderer renderers[];};
layout(std430,binding = 4) buffer i{uint ids[];};
layout(std430, binding = 3) buffer _m_buffs{matrix matrixes[];};
layout(std430,binding = 5) buffer a{uint atomics[];};

uniform uint num;
uniform vec3 camPos;
uniform vec3 camForward;
uniform mat4 view;
uniform mat4 vRot;
uniform mat4 projection;
uniform vec3 floatingOrigin;
uniform int stage;

uniform float radius;
uniform mat3 camInv;
uniform vec3 cullPos;
uniform vec2 screen;
//vector(transforms, _transform, 0);


bool planeIntersect(float plane[4], vec3 point) {
	return point.x*plane[0] + point.y * plane[1] + point.z * plane[2] + plane[3] < 0;
}


layout( local_size_x = 64,  local_size_y = 1, local_size_z = 1) in;
void main () {

	uint gid = gl_GlobalInvocationID.x;
	if(gid >= num)
		return;
	//plane
		// float a, b, c, d;
		// a = camForward.x;
		// b = camForward.y;
		// c = camForward.z;
		// d = a * -camPos.x + b * -camPos.y + c * -camPos.z;
		// float plane[] = { a,b,c,d };

		_transform transform = transforms[ids[gid]];
		vec3 p = camInv * (transform.position - cullPos);
		float _radius = radius * length(transform.scale);
		//	uint renderid = renderers[gid].renderer;
		if(p.z - _radius < 0.f
			&& (abs(p.x) - _radius) / abs(p.z) < screen.x
			&& (abs(p.y) - _radius) / abs(p.z) < screen.y){

			uint buffsid = atomicAdd(atomics[0],1);

			matrixes[buffsid].model = translate(identity(),transform.position) * rotate(identity(),transform.rotation) * scale(identity(),transform.scale);
			matrixes[buffsid].mvp = projection * vRot * view * matrixes[buffsid].model;

			matrixes[buffsid].normal = mat4(transpose(inverse(mat3(rotate(identity(),transform.rotation)))));
		}

}
