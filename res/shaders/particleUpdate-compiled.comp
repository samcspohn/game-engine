#version 430 core

#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_storage_buffer_object : enable
#define GLSLIFY 1
#define GLSLIFY 1
mat4 translate(mat4 m, vec3 translation){
		mat4 t = {{1,0,0,translation.x},
		{0,1,0,translation.y,},
		{0,0,1,translation.z}
		,{0,0,0,1}};
		return m * transpose(t);
}
mat4 scale(mat4 m, vec3 scale){
	mat4 s = {{scale.x,0,0,0}, {0,scale.y,0,0},{0,0,scale.z,0},{0,0,0,1}};
	return m * transpose(s);
}

mat4 rotate(mat4 m, vec4 q){
	mat4 r1 = {{q.w,q.z,-q.y,q.x},{-q.z,q.w,q.x,q.y},{q.y,-q.x,q.w,q.z},{-q.x,-q.y,-q.z,q.w}};
	mat4 r2 = {{q.w,q.z,-q.y,-q.x},{-q.z,q.w,q.x,-q.y},{q.y,-q.x,q.w,-q.z},{q.x,q.y,q.z,q.w}};
	mat4 r = r1 * r2;
	r[0][3] = r[1][3] = r[2][3] = r[3][0] = r[3][1] = r[3][2] = 0;
	r[3][3] = 1;
	return m * r;
}

mat4 identity(){
	mat4 i = {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}};
	return i;
}
vec4 lookAt(in vec3 lookAt, in vec3 up) {
vec3 forward = lookAt;
forward = normalize(forward);
vec3 right = normalize(cross(up, forward));
up = normalize(cross(forward,right));

#define m00 right.x
#define m01 up.x
#define m02 forward.x
#define m10 right.y
#define m11 up.y
#define m12 forward.y
#define m20 right.z
#define m21 up.z
#define m22 forward.z

vec4 ret;
ret.w = sqrt(1.0f + m00 + m11 + m22) * 0.5f;
float w4_recip = 1.0f / (4.0f * ret.w);
ret.x = (m21 - m12) * w4_recip;
ret.y = (m02 - m20) * w4_recip;
ret.z = (m10 - m01) * w4_recip;

#undef m00
#undef m01
#undef m02
#undef m10
#undef m11
#undef m12
#undef m20
#undef m21
#undef m22
return ret;
}

mat4 rotationMatrix(vec3 axis, float angle)
{
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;
    
    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                0.0,                                0.0,                                0.0,                                1.0);
}

vec3 rotate(vec3 axis, float angle, vec3 vec){
	if(angle == 0){
		return vec;
	}
	return (rotationMatrix(axis, angle) * vec4(vec,1)).xyz;
}

const uint RIGHT = 0x0000ffff;
const uint LEFT = 0xffff0000;
uint getLeft(uint field) {
	return field >> 16; // >>> operator 0-fills from left
}
uint getRight(uint field) {
	return field & RIGHT;
}

void setHighBits(inout uint o, uint left){
	o = (left << 16) | (o & RIGHT);
}
void setLowBits(inout uint o, uint right){
	o = (o & LEFT) | (right);
}
uint getHighBits(inout uint o){
	return getLeft(o);
}
uint getLowBits(inout uint o){
	return getRight(o);
}

#define M_PI 3.1415926535897932384626433832795
float PHI = 1.61803398874989484820459;  // Î¦ = Golden Ratio   
float rand(in vec2 xy, in float seed){
    xy += vec2(1);
    return fract(tan(distance(xy*PHI, xy)*sin(seed))*xy.x);
}
struct rng{
	vec2 r;
	float s;
	// void setSeed(vec2 rin, float seedin){
	// 	r = rin;
	// 	s = seedin;
	// }
	
	// float gen(){
	// 	float ret = rand(r, s);
	// 	r = r + vec2(1.21212121,2.12121212);
	// 	s += 2.121212112f;
	// 	return ret;
	// }
};
void setSeed(inout rng g, vec2 rin, float seedin){
	g.r = rin;
	g.s = seedin;
}

float gen(inout rng g){
	float ret = rand(g.r, g.s);
	g.r = g.r + vec2(1.21212121,2.12121212);
	g.s += 2.121212112f;
	return ret;
}
vec4 randVec4(inout rng g){
	return vec4(
    gen(g) - 0.5f,
    gen(g) - 0.5f,
    gen(g) - 0.5f,
    gen(g) - 0.5f
    );
}
vec3 randVec3(inout rng g){
	return vec3(
    gen(g) - 0.5f,
    gen(g) - 0.5f,
    gen(g) - 0.5f
    );
}
#define GLSLIFY 1
struct particle{
    vec3 position;
    uint emitter;
    vec3 scale;
    uint emitter_prototype;
    vec4 rotation;

    vec3 velocity;
    int live;

    float life;
    int next;
    int prev;
    float life2;
    
    vec3 position2;
    int visible;
    vec3 velocity2;
    float l;
};
struct emitter_prototype{
    float emission_rate;
    float lifetime;
    float rotation_rate;
    float dispersion;

    // vec4 color;

    float minSpeed;
    float maxSpeed;
    float lifetime2;
    int live;

    vec3 scale;
    int billboard;

    int velAlign;
    float radius;
    int p2;
    int trail;
    vec4 colorLife[100];
    float sizeLife[100];
};
struct emitter{
    uint transform;
    uint emitter_prototype;
    float emission;
    int live;

    vec2 p;
    int last;
    int frame;
};

struct emitterInit{
    uint transformID;
    uint emitterProtoID;
    int live;
    int id;
}; 

struct d{
    // vec4 rot;
	uint xy;
    float z;
    uint qxy;
    uint qzw;
	// uint qwx;
    // uint qyz;
	uint scale_xy;
	uint protoID_life;
	// uint key_life;
};

uint getX(inout d item){
    return getHighBits(item.xy);
}
void setX(inout d item, uint x1){
    setHighBits(item.xy, x1);
}

uint getY(inout d item){ // 0x0000ffff
    return getLowBits(item.xy);
}
void setY(inout d item, uint y2){
    setLowBits(item.xy,y2);
}

void setZ(inout d item, float z){
    item.z = z;
    // item.z1 = (item.z & 0x0000ffff) | (floatBitsToUint(z) & 0xffff0000);
}
float getZ(inout d item){
    return item.z;
    // return uintBitsToFloat(item.z & 0xffff0000);
}
void setScale(inout d item, vec2 scale){
    item.scale_xy = (floatBitsToUint(scale.x) & LEFT) | (floatBitsToUint(scale.y) >> 16);
}
vec2 getScale(inout d item){
    return vec2(uintBitsToFloat(item.scale_xy & LEFT), uintBitsToFloat(getLowBits(item.scale_xy) << 16));
}

void setRotation(inout d item, vec4 quat){
    quat = normalize(quat);
    // setHighBits(item.qwx,uint(quat.w * 32768 + 32768));
    // setLowBits(item.qwx,uint(quat.x * 32768 + 32768));
    // setHighBits(item.qyz,uint(quat.y * 32768 + 32768));
    // setLowBits(item.qyz,uint(quat.z * 32768 + 32768));

    setHighBits(item.qxy,uint(quat.x * 32768 + 32768));
    setLowBits(item.qxy,uint(quat.y * 32768 + 32768));
    setHighBits(item.qzw,uint(quat.z * 32768 + 32768));
    setLowBits(item.qzw,uint(quat.w * 32768 + 32768));
    // item.rot = quat;
}

vec4 getRotation(inout d item){
    // return item.rot;
    return normalize(vec4((float(getHighBits(item.qxy)) - 32768) / 32768,
                (float(getLowBits(item.qxy)) - 32768) / 32768,
                (float(getHighBits(item.qzw)) - 32768) / 32768,
                (float(getLowBits(item.qzw)) - 32768) / 32768));
    // return normalize(vec4((float(getHighBits(item.qwx)) - 32768) / 32768,
    //         (float(getLowBits(item.qwx)) - 32768) / 32768,
    //         (float(getHighBits(item.qyz)) - 32768) / 32768,
    //         (float(getLowBits(item.qyz)) - 32768) / 32768));
}

uint protoID(inout d item){
    return item.protoID_life >> 16;
}
void protoID(inout d item, uint id){
    item.protoID_life = (item.protoID_life & 0x0000ffff) | (id << 16);
}
// uint key(inout d item){
//     return item.key_life >> 16;
// }
// void key(inout d item, uint id){
//     item.key_life = (item.key_life & 0x0000ffff) | (id << 16);
// }
float life(inout d item){
    return uintBitsToFloat((item.protoID_life & 0x0000ffff) << 16);
}
void life(inout d item, float l){
    item.protoID_life = (item.protoID_life & 0xffff0000) | (floatBitsToUint(l) >> 16);
}

#define GLSLIFY 1
struct _transform {
	vec3 position; int id;
	vec3 scale; int parent;
	vec4 rotation;
	int childrenBegin;
	int childrenEnd;
	int prevSibling;
	int nextSibling;
};

struct _emission{
    vec3 position;
    uint emitter_prototype;
    vec3 direction;
    int emitterID;
    vec3 scale;
    int last;
};

struct _burst{
    vec3 position;
    uint emitter_prototype;
    vec3 direction;
    uint count;
    vec3 scale;
    int p1;
};

layout(std430,binding = 0) buffer t{_transform transforms[];};
layout(std430,binding = 1) buffer ac{int atomicCounters[];};
layout(std430,binding = 2) buffer p{particle particles[];};
layout(std430,binding = 3) buffer ep{emitter_prototype prototypes[];};
layout(std430,binding = 4) buffer e{emitter emitters[];};
// layout(std430,binding = 5) buffer r{uint rng[];};
layout(std430,binding = 5) buffer bp{uint burstParticles[];};
layout(std430,binding = 6) buffer de{uint dead[];};
layout(std430,binding = 7) buffer ed{_emission emitted[];};
layout(std430,binding = 8) buffer ei{emitterInit emittersInits[];};
layout(std430,binding = 9) buffer pb{_burst particleBursts[];};
layout(std430,binding = 10) buffer lp{uint livingParticles[];};

const uint liveParticles = 0;
const uint burstCounter = 1;
const uint emittedCounter = 2;

uniform uint count;
uniform uint burstOffset;
uniform float deltaTime;
uniform float time;
uniform int max_particles;
uniform uint stage;
uniform vec3 floatingOrigin;
shared uint garbage[130];

void update(uint index, float dt){

    uint id = livingParticles[index];
     if(particles[id].live == 1){
        particle p = particles[id];
        emitter_prototype proto = prototypes[p.emitter_prototype];
        p.position += p.velocity * dt;

        if(p.next < -1){
            if(emitters[-p.next - 2].last == id)
                p.position2 = transforms[emitters[-p.next - 2].transform].position;
        }else{
            p.position2 += p.velocity2 * dt;
            // p.position2 = particles[p.next].position;
        }

        // p.position2 = p.position + vec3(10);
        // p.position -= floatingOrigin;
        p.life -= dt / p.l;
        p.life2 -= dt / p.l;

        // p.life -= dt / proto.lifetime;
        // p.life2 -= dt / proto.lifetime;

        // p.life -= 0.05f;
        // p.life2 -= 0.05f;

        if(p.life <= 0.f)
        {
            int index = atomicAdd(atomicCounters[liveParticles],-1);
            dead[index - 1] = id;
            // uint index = atomicAdd(garbage[0],1);
            // garbage[index + 2] = id;
            p.live = 0;
            p.next = p.prev = -1;
            // return;
        }

        particles[id] = p;
    }
}

void initEmitters(uint id){
    emitterInit ei = emittersInits[id];
    emitter e = emitters[ei.id];
    if(e.frame > 0 && e.last != -1){
        particles[e.last].next = -1;
        particles[e.last].position2 = transforms[e.transform].position;
        particles[e.last].velocity2 = vec3(0);//p.velocity;
        particles[e.last].life2 = 1;
    }
    e.emitter_prototype = ei.emitterProtoID;
    e.transform = ei.transformID;
    e.live = ei.live;
    e.frame = 0;
    e.emission = 1;//prototypes[e.emitter_prototype].emission_rate * deltaTime;
    e.last = -1;
    emitters[ei.id] = e;
}

void makeParticle(inout particle p, inout emitter_prototype ep, inout rng generator, inout float particle_count, vec3 tpos, vec4 trot, vec3 tscale, uint epId, float dt, uint eId){

    p.position = tpos + normalize(randVec3(generator)) * tscale * ep.radius;
    // p.rotation  = transforms[e.transform].rotation;
    p.scale = tscale * ep.scale;
    p.life = 1.f;
    p.l = max(ep.lifetime2 + gen(generator) * abs(ep.lifetime - ep.lifetime2),0.0001f);
    p.emitter = eId;
    p.emitter_prototype = epId;
    vec3 random = rotate(vec3(1,0,0),gen(generator) * ep.dispersion,vec3(0,0,ep.minSpeed + gen(generator) * (ep.maxSpeed - ep.minSpeed)));
    random = rotate(vec3(0,0,1),gen(generator) * 2 * M_PI,random);
    p.velocity = vec3(rotate(identity(), trot) * vec4(random * tscale,1));
    
    if(ep.velAlign == 1){
        vec3 dir = cross(p.velocity,randVec3(generator));
        p.rotation = lookAt(dir,p.velocity);
    }else{
        p.rotation = normalize(randVec4(generator));
    }

    p.position += p.velocity * dt * particle_count;
    p.position2 = p.position;
    p.velocity2 = p.velocity;
    p.life -= dt * particle_count++ / p.l;
}

void emit(uint thread_id){
    // live[0] = 1;
    
    emitter e = emitters[thread_id];
    if(e.live == 1){

        emitter_prototype ep = prototypes[e.emitter_prototype];
        e.emission += ep.emission_rate * deltaTime;
        e.frame++;
        int emission = int(e.emission);
        
        int new_particles_start = atomicAdd(atomicCounters[liveParticles],emission);
        int end = new_particles_start + emission;
        float dt = deltaTime;
        dt /= float(emission + 1);
        float particle_count = 0.0;
        vec2 id = vec2(thread_id % max_particles, thread_id / max_particles);
        rng generator;
        setSeed(generator,id,time);
        for(int i = new_particles_start; i < end && i < max_particles; ++i){
            // emitted[i].position = transforms[e.transform].position;
            // emitted[i].emitterID = int(thread_id);
            // emitted[i].emitter_prototype = e.emitter_prototype;
            // emitted[i].scale = transforms[e.transform].scale;
            // emitted[i].last = e.last;

            // initParticle()

            int x = int(dead[i]);
            particle p;
            makeParticle(p,ep,generator,particle_count, transforms[e.transform].position,transforms[e.transform].rotation,transforms[e.transform].scale, e.emitter_prototype, dt, thread_id);

            if(ep.trail == 1){
                if(e.frame > 0 && e.last != -1){
                    particles[e.last].next = int(x);
                    particles[e.last].position2 = p.position;
                    particles[e.last].velocity2 = p.velocity;
                    particles[e.last].life2 = p.life;
                }
                p.next = -int(thread_id) - 2;
                p.prev = e.last;
                e.last = int(x);
            }

            p.live = 1;
            particles[x] = p;
        }
        e.emission -= float(uint(e.emission));
    }else{
        e.frame = 0;
        e.last = -1;
    }
    emitters[thread_id] = e;

}

void burst(uint thread_id){
    _burst e = particleBursts[thread_id];

    emitter_prototype ep = prototypes[e.emitter_prototype];
    
    int new_particles = atomicAdd(atomicCounters[liveParticles],int(e.count));
    int burst_start = atomicAdd(atomicCounters[burstCounter],int(e.count));
    int end = burst_start + int(e.count);
    for(int i = burst_start; i < end && new_particles + i < max_particles; ++i){
        burstParticles[i] = thread_id;
    }
}

void makeBursts(uint thread_id){
        _burst e = particleBursts[burstParticles[thread_id]];

        emitter_prototype ep = prototypes[e.emitter_prototype];
        int x = int(dead[burstOffset + thread_id]);
        particle p;

        vec2 id = vec2(thread_id % max_particles, thread_id / max_particles);
        rng generator;
        setSeed(generator,id,time);

        float p_count = 0;
        makeParticle(p,ep,generator,p_count, e.position,lookAt(e.direction,vec3(0,1,0.000001)),e.scale, e.emitter_prototype, deltaTime, -1);
        p.live = 1;
        particles[x] = p;
}

void countParticles(uint thread_id){
    if(particles[thread_id].life > 0.f){
        uint index = uint(atomicAdd(atomicCounters[2],1));
        livingParticles[index] = thread_id;
    }

}

layout( local_size_x = 128,  local_size_y = 1, local_size_z = 1) in;
void main () {
    uint gid = gl_GlobalInvocationID.x;
    if(gid < count){
        switch(stage){
            case 0:
                emit(gid);
                break;
            case 1:
                update(gid,deltaTime);
                break;
            case 2:
                initEmitters(gid);
                break;
            case 3:
                burst(gid);
                break;
            case 4:
                makeBursts(gid);
                break;
            case 5:
                countParticles(gid);
                break;
            case 6:
                atomicCounters[2] = 0;
                break;
        }
    }
}