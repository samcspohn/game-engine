#version 430 core

#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_storage_buffer_object : enable
//#extension GL_NV_gpu_shader5 : enable

#include "transform.glsl"
#include "util.glsl"


#define vector(name, type ,_binding) layout(std430,binding = _binding) buffer _name{uint size; type name[];}


struct renderer {
	uint transform;
	uint id;
};
struct renderMeta{
	float radius;
	float min_;
	float max_;
	uint isBillboard;
};

layout(std430,binding = 0) buffer t{_transform transforms[];};
layout(std430,binding = 1) buffer r{renderer renderers[];};
layout(std430, binding = 3) buffer _m_buffs{matrix matrixes[];};
layout(std430,binding = 5) buffer o{uint offsets[];};
layout(std430,binding = 8) buffer rm{renderMeta renderMetas[];};
layout(std430,binding = 6) buffer it{int transformIds[];};
layout(std430,binding = 7) buffer ttc{_transform transformsToCopy[];};

layout(std430,binding = 8) buffer tp{float positions[];};
layout(std430,binding = 9) buffer tr{vec4 rotations[];};
layout(std430,binding = 10) buffer ts{float scales[];};

uniform int stage;
uniform uint num;
// uniform float radius;
uniform vec3 cullPos;
uniform vec2 screen;
uniform vec3 floatingOrigin;
uniform mat3 camInv;
uniform mat4 view;
uniform mat4 vRot;
uniform mat4 projection;
uniform vec3 camUp;

//vector(transforms, _transform, 0);


bool planeIntersect(float plane[4], vec3 point) {
	return point.x*plane[0] + point.y * plane[1] + point.z * plane[2] + plane[3] < 0;
}

void updateTransforms(uint id){
	transforms[transformIds[id]] = transformsToCopy[id];
}
void updatePositions(uint id){
	uint i = id * 3;
	transforms[transformIds[id]].position = vec3(positions[i], positions[i + 1], positions[i + 2]);
}
void updateRotations(uint id){
	transforms[transformIds[id]].rotation = rotations[id];
}
void updateScales(uint id){
	uint i = id * 3;
	transforms[transformIds[id]].scale = vec3(scales[i], scales[i + 1], scales[i + 2]);
}
layout( local_size_x = 64,  local_size_y = 1, local_size_z = 1) in;
void main () {

	uint gid = gl_GlobalInvocationID.x;
	if(gid < num){
		switch(stage){
			case -1:
				updateTransforms(gid);
				break;
			case -2:
				updatePositions(gid);
				break;
			case -3:
				updateRotations(gid);
				break;
			case -4:
				updateScales(gid);
				break;
			
			default:
			{
				_transform transform = transforms[renderers[gid].transform];
				transform.position -= floatingOrigin;
				vec3 p = camInv * (transform.position);
				float _radius = renderMetas[renderers[gid].id].radius * length(transform.scale);
				//	uint renderid = renderers[gid].renderer;
				float dist = length(p);
				float r = abs(_radius / dist); 
				bool f = r > renderMetas[renderers[gid].id].min_ && r < renderMetas[renderers[gid].id].max_;
				// f = true;
				if(f 
					&& p.z - _radius < 0.f
					&& (abs(p.x) - _radius) / dist < screen.x
					&& (abs(p.y) - _radius) / dist < screen.y){

					// float isBillboard = ;
					uint buffsid = atomicAdd(offsets[renderers[gid].id],1);

					// matrixes[buffsid].model = (translate(transform.position) * rotate(transform.rotation) * scale(transform.scale) * (1.f - isBillboard))
					//  + (translate(transform.position) * rotate(lookAt(transform.position - cullPos,vec3(0,1,0))) * scale(transform.scale) * isBillboard);
					if(renderMetas[renderers[gid].id].isBillboard == 1){
						matrixes[buffsid].model = 
						(translate(transform.position) * rotate(lookAt(transform.position,camUp + vec3(0.001))) * scale(transform.scale));// * renderMetas[renderers[gid].id].isBillboard
						//  + 
						// (translate(transform.position) * rotate(transform.rotation) * scale(transform.scale)) * (1 - renderMetas[renderers[gid].id].isBillboard);
					}else{
						matrixes[buffsid].model = translate(transform.position) * rotate(transform.rotation) * scale(transform.scale);
					}
					matrixes[buffsid].mvp = projection * vRot * matrixes[buffsid].model;

					matrixes[buffsid].normal = mat4(transpose(inverse(mat3(rotate(transform.rotation) * scale(transform.scale)))));
				}
			}
			break;
		}

	}
}
