#version 430 core

#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_storage_buffer_object : enable


struct _transform {
	vec3 position; int id;
	vec3 scale; int parent;
	vec4 rotation;
	int childrenBegin;
	int childrenEnd;
	int prevSibling;
	int nextSibling;
};
struct particle{
    vec3 position;
    uint emitter;
    vec3 scale;
    uint emitter_prototype;
    vec4 rotation;

    vec3 velocity;
    int live;

    float life;
    uint next;
    uint prev;
    float p;
};
struct emitter_prototype{
    float emission_rate;
    float lifetime;
    float rotation_rate;
    int id;
    vec4 color;
    vec3 velocity;
    int live;
    vec3 scale;
    int billboard;
};
struct emitter{
    uint transform;
    uint emitter_prototype;
    float emission;
    int live;
};
layout(std430,binding = 0) buffer t{_transform transforms[];};
layout(std430,binding = 2) buffer p{particle particles[];};
layout(std430,binding = 3) buffer ep{emitter_prototype prototypes[];};
layout(std430,binding = 4) buffer e{emitter emitters[];};
layout(std430,binding = 5) buffer r{uint rng[];};
layout(std430,binding = 6) buffer d{uint dead[];};
layout(std430,binding = 1) buffer ac{uint atomicCounters[];};

const uint liveParticles = 0;
const uint destroyCounter = 1;
uniform uint count;
uniform float deltaTime;
uniform float time;
uniform uint max_particles;
uniform uint stage;
uniform vec3 cameraPosition;
uniform vec3 cameraUp;

uint xorshf96(void) {          //period 2^96-1
uint t;
    rng[0] ^= rng[0] << 16;
    rng[0] ^= rng[0] >> 5;
    rng[0] ^= rng[0] << 1;

   t = rng[0];
   rng[0] = rng[1];
   rng[1] = rng[2];
   rng[2] = t ^ rng[0] ^ rng[1];

  return rng[2];
}


float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

float PHI = 1.61803398874989484820459;  // Î¦ = Golden Ratio   

float gold_noise(in vec2 xy, in float seed){
       return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);
}

// float randf() {
//     // vec2 co;
//     // co.x = atomicAdd(rng[0],rng[2] - 1);
//     // co.y = atomicAdd(rng[1],rng[0] - 1);
//     // atomicAdd(rng[2],rng[1] - 1);
//     // return min(float(co.x),float(co.y)) / max(float(co.x),float(co.y));

//     return rand(vec2(deltaTime, gl_GlobalInvocationID.x));

//     // uint r = xorshf96();
//     // uint x = 100;
// 	// return float(r) / float (200) ;// / float(4294967295);
// }

mat4 translate(mat4 m, vec3 translation){
		mat4 t = {{1,0,0,translation.x},
		{0,1,0,translation.y,},
		{0,0,1,translation.z}
		,{0,0,0,1}};
		return m * transpose(t);
}
mat4 scale(mat4 m, vec3 scale){
	mat4 s = {{scale.x,0,0,0}, {0,scale.y,0,0},{0,0,scale.z,0},{0,0,0,1}};
	return m * transpose(s);
}

mat4 rotate(mat4 m, vec4 q){
	mat4 r1 = {{q.w,q.z,-q.y,q.x},{-q.z,q.w,q.x,q.y},{q.y,-q.x,q.w,q.z},{-q.x,-q.y,-q.z,q.w}};
	mat4 r2 = {{q.w,q.z,-q.y,-q.x},{-q.z,q.w,q.x,-q.y},{q.y,-q.x,q.w,-q.z},{q.x,q.y,q.z,q.w}};
	return m * r1 * r2;
}

mat4 identity(){
	mat4 i = {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}};
	return i;
}
vec4 lookAt(in vec3 lookAt, in vec3 upDirection) {
vec3 forward = lookAt; vec3 up = upDirection;
forward = normalize(forward);
vec3 right = normalize(cross(up, forward));
up = normalize(cross(forward,right));

#define m00 right.x
#define m01 up.x
#define m02 forward.x
#define m10 right.y
#define m11 up.y
#define m12 forward.y
#define m20 right.z
#define m21 up.z
#define m22 forward.z

vec4 ret;
ret.w = sqrt(1.0f + m00 + m11 + m22) * 0.5f;
float w4_recip = 1.0f / (4.0f * ret.w);
ret.x = (m21 - m12) * w4_recip;
ret.y = (m02 - m20) * w4_recip;
ret.z = (m10 - m01) * w4_recip;

#undef m00
#undef m01
#undef m02
#undef m10
#undef m11
#undef m12
#undef m20
#undef m21
#undef m22

return ret;
}

void begin(uint thread_id){
    // live[0] = 1;
    
    emitter e = emitters[thread_id];
    if(e.live == 1){

        uint emission = uint(e.emission);
        uint new_particles_start = atomicAdd(atomicCounters[liveParticles],emission);
        atomicMin(atomicCounters[liveParticles],max_particles);
        uint end = new_particles_start + emission;
        
        for(uint i = new_particles_start; i < end && i < max_particles; ++i){
            uint x = dead[i];
            particles[x].position = transforms[e.transform].position;
            particles[x].rotation = normalize(vec4(gold_noise(vec2(thread_id % max_particles, thread_id / max_particles),time + 3) - 0.5f,
            gold_noise(vec2(thread_id % max_particles, thread_id / max_particles),time + 4) - 0.5f,
            gold_noise(vec2(thread_id % max_particles, thread_id / max_particles),time + 5) - 0.5f,
            gold_noise(vec2(thread_id % max_particles, thread_id / max_particles),time + 6) - 0.5f
            ));
            // particles[x].rotation  = transforms[e.transform].rotation;
            particles[x].scale = transforms[e.transform].scale * prototypes[e.emitter_prototype].scale;
            particles[x].life = 1.f;
            particles[x].emitter = thread_id;
            particles[x].emitter_prototype = e.emitter_prototype;
            vec3 random = vec3(
            gold_noise(vec2(thread_id % max_particles, thread_id / max_particles),time) - 0.5f,
            gold_noise(vec2(thread_id % max_particles, thread_id / max_particles),time + 1) - 0.5f,
            gold_noise(vec2(thread_id % max_particles, thread_id / max_particles),time + 2) - 0.5f);
            // vec3 random = vec3(noise(thread_id * time), noise(thread_id * (time + 1)),noise(thread_id * (time + 2)));
            // prototypes[e.emitter_prototype].velocity
            particles[x].velocity = vec3(rotate(identity(),particles[x].rotation) * vec4(random * prototypes[e.emitter_prototype].velocity * transforms[e.transform].scale,1));
            particles[x].live = 1;
        }
    }
}

void update(uint id){

    if(particles[id].live == 1){
        particle p = particles[id];
        emitter_prototype proto = prototypes[p.emitter_prototype];
        p.position += p.velocity * deltaTime;
        p.life -= deltaTime / prototypes[p.emitter_prototype].lifetime;

        if(proto.billboard == 1)
            p.rotation = lookAt(cameraPosition - p.position,cameraUp);
        if(p.life < 0)
        {
            uint index = atomicAdd(atomicCounters[liveParticles],-1);
            dead[index - 1] = id;
            p.live = 0;
        }
        particles[id] = p;
    }
}

// void cleanup(uint thread_id){

//     uint liveMoved = atomicAdd(atomicCounters[liveParticles],-1);
//     uint toDestroyIndex = atomicAdd(atomicCounters[destroyCounter],-1);
//     // live[toDestroy[thread_id]] = particles[liveMoved];
//     dead[liveMoved - 1] = live[toDestroy[toDestroyIndex - 1]];
//     live[toDestroy[toDestroyIndex - 1]] = live[liveMoved - 1];
// }

layout( local_size_x = 64,  local_size_y = 1, local_size_z = 1) in;
void main () {
    uint gid = gl_GlobalInvocationID.x;
        if( stage == 0 && gid < count) // only emitters
            begin(gid);
        if(stage == 1 && gid < max_particles)
            update(gid);


}