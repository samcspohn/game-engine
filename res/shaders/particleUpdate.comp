#version 430 core

#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_storage_buffer_object : enable
#include "particle.glsl"
#include "transform.glsl"
#include "util.glsl"

layout(std430,binding = 0) buffer t{_transform transforms[];};
layout(std430,binding = 2) buffer p{particle particles[];};
layout(std430,binding = 3) buffer ep{emitter_prototype prototypes[];};
layout(std430,binding = 4) buffer e{emitter emitters[];};
layout(std430,binding = 7) buffer elp{int emitters_last_particle[];};
layout(std430,binding = 5) buffer r{uint rng[];};
layout(std430,binding = 6) buffer d{uint dead[];};
layout(std430,binding = 1) buffer ac{uint atomicCounters[];};

const uint liveParticles = 0;
const uint destroyCounter = 1;
uniform uint count;
uniform float deltaTime;
uniform float time;
uniform uint max_particles;
uniform uint stage;
uniform vec3 cameraPosition;
uniform vec3 cameraForward;
uniform vec3 cameraUp;

float PHI = 1.61803398874989484820459;  // Î¦ = Golden Ratio   
float rand(in vec2 xy, in float seed){
    xy += vec2(1);
    return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);
}

void begin(uint thread_id){
    // live[0] = 1;
    
    emitter e = emitters[thread_id];
    if(e.live == 1){

        emitter_prototype ep = prototypes[e.emitter_prototype];
        uint emission = uint(e.emission);
        uint new_particles_start = atomicAdd(atomicCounters[liveParticles],emission);
        atomicMin(atomicCounters[liveParticles],max_particles);
        uint end = new_particles_start + emission;
        
        for(uint i = new_particles_start; i < end && i < max_particles; ++i){
            int x = int(dead[i]);
            particle p;
            p.position = transforms[e.transform].position;
            vec2 id = vec2(thread_id % max_particles, thread_id / max_particles);
            p.rotation = normalize(vec4(rand(id,time + 3) - 0.5f,
            rand(id,time + 4) - 0.5f,
            rand(id,time + 5) - 0.5f,
            rand(id,time + 6) - 0.5f
            ));
            // p.rotation  = transforms[e.transform].rotation;
            p.scale = transforms[e.transform].scale * ep.scale;
            p.life = 1.f;
            p.emitter = thread_id;
            p.emitter_prototype = e.emitter_prototype;
            vec3 random = vec3(
            rand(id,time) - 0.5f,
            rand(id,time + 1) - 0.5f,
            rand(id,time + 2) - 0.5f);
            p.velocity = vec3(rotate(identity(),transforms[e.transform].rotation) * vec4(random * ep.velocity * transforms[e.transform].scale,1));
            
            // set trail
            if(ep.trail == 1){
                if(e.last_particle != -1){
                    particles[emitters_last_particle[thread_id]].next = int(x);
                }
                p.next = -int(thread_id) - 2;
                p.prev = emitters_last_particle[thread_id];
                emitters_last_particle[thread_id] = int(x);
            }

            p.live = 1;
            particles[x] = p;
        }
        // emitters[thread_id] = e;
    }
}

void update(uint id){

    if(particles[id].live == 1){
        particle p = particles[id];
        emitter_prototype proto = prototypes[p.emitter_prototype];
        p.position += p.velocity * deltaTime;
        p.life -= deltaTime / prototypes[p.emitter_prototype].lifetime;

        if(proto.billboard == 1)
            p.rotation = lookAt(-cameraForward, (cameraForward == vec3(0,0,1) || cameraForward == vec3(0,0,-1)) ? vec3(1,0,0) : cameraUp);
        if(p.life < 0)
        {
            uint index = atomicAdd(atomicCounters[liveParticles],-1);
            dead[index - 1] = id;
            p.live = 0;
            p.next = p.prev = -1;
        }
        particles[id] = p;
    }
}

// void cleanup(uint thread_id){

//     uint liveMoved = atomicAdd(atomicCounters[liveParticles],-1);
//     uint toDestroyIndex = atomicAdd(atomicCounters[destroyCounter],-1);
//     // live[toDestroy[thread_id]] = particles[liveMoved];
//     dead[liveMoved - 1] = live[toDestroy[toDestroyIndex - 1]];
//     live[toDestroy[toDestroyIndex - 1]] = live[liveMoved - 1];
// }

layout( local_size_x = 192,  local_size_y = 1, local_size_z = 1) in;
void main () {
    uint gid = gl_GlobalInvocationID.x;
    if( stage == 0 && gid < count) // only emitters
        begin(gid);
    if(stage == 1 && gid < max_particles)
        update(gid);
            float x = 10.f;
    int y = floatBitsToInt(x) >> 2;
}