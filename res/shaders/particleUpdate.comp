#version 430 core

#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_storage_buffer_object : enable
#include "util.glsl"
#include "particle.glsl"
#include "transform.glsl"


struct _emission{
    vec3 position;
    uint emitter_prototype;
    vec3 direction;
    int emitterID;
    int last;
};


layout(std430,binding = 0) buffer t{_transform transforms[];};
layout(std430,binding = 1) buffer ac{int atomicCounters[];};
layout(std430,binding = 2) buffer p{particle particles[];};
layout(std430,binding = 3) buffer ep{emitter_prototype prototypes[];};
layout(std430,binding = 4) buffer e{emitter emitters[];};
layout(std430,binding = 5) buffer r{uint rng[];};
layout(std430,binding = 6) buffer de{uint dead[];};
layout(std430,binding = 7) buffer ed{_emission emitted[];};
layout(std430,binding = 8) buffer ei{emitterInit emittersInits[];};

const uint liveParticles = 0;
const uint destroyCounter = 1;
const uint emittedCounter = 2;

uniform uint count;
uniform float deltaTime;
uniform float time;
uniform int max_particles;
uniform uint stage;
uniform vec3 cameraPosition;
uniform vec3 cameraForward;
uniform vec3 cameraUp;
uniform vec3 floatingOrigin;
shared uint garbage[130];

float PHI = 1.61803398874989484820459;  // Î¦ = Golden Ratio   
float rand(in vec2 xy, in float seed){
    xy += vec2(1);
    return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);
}
void initParticle(_emission e, uint x){
    emitter_prototype ep = prototypes[e.emitter_prototype];
    particle p;
    p.position = e.position;
    vec2 id = vec2(x % max_particles, x / max_particles);
    p.rotation = normalize(vec4(
    rand(id,time + 3) - 0.5f,
    rand(id,time + 4) - 0.5f,
    rand(id,time + 5) - 0.5f,
    rand(id,time + 6) - 0.5f
    ));
    // p.rotation  = transforms[e.transform].rotation;
    p.scale = ep.scale;
    p.life = 1.f;
    p.emitter = e.emitterID;
    p.emitter_prototype = e.emitter_prototype;
    vec3 random = vec3(
    rand(id,time) - 0.5f,
    rand(id,time + 1) - 0.5f,
    rand(id,time + 2) - 0.5f);
    // vec3(rotate(identity(),transforms[e.transform].rotation) * vec4(random * ep.velocity * ep.scale,1))
    p.velocity = random * ep.velocity;
    
    // p.life -= dt * count++ / prototypes[p.emitter_prototype].lifetime;
    // set trail
    if(ep.trail == 1){
        if(e.last > -1){
            particles[e.last].next = int(x);
            particles[e.last].position2 = p.position;
            particles[e.last].velocity2 = p.velocity;
            particles[e.last].life2 = p.life;
        }
        p.next = -int(e.emitterID) - 2;
        p.prev = e.last;
        emitters[e.emitterID].last = int(x);
    }

    p.live = 1;
    atomicAdd(atomicCounters[liveParticles],1);
    if(atomicCounters[liveParticles] > max_particles)
        atomicMin(atomicCounters[liveParticles],max_particles);
    particles[x] = p;
}

void update(uint id, float dt){

    // uint localID = gl_LocalInvocationID.x;
    // if(localID == 0)
    //     garbage[0] = 0;
    // barrier();
    if(particles[id].live == 1 && stage == 1){
        particle p = particles[id];
        emitter_prototype proto = prototypes[p.emitter_prototype];
        p.position += p.velocity * dt;

        if(p.next < -1 && emitters[-p.next - 2].last == id){
            p.position2 = transforms[emitters[-p.next - 2].transform].position;
        }else{
            p.position2 += p.velocity2 * dt;
            // p.position2 = particles[p.next].position;
        }

        // p.position -= floatingOrigin;
        p.life -= dt / prototypes[p.emitter_prototype].lifetime;
        p.life2 -= dt / prototypes[p.emitter_prototype].lifetime;

        if(p.life < 0)
        {
            int index = atomicAdd(atomicCounters[liveParticles],-1);
            dead[index - 1] = id;
            // uint index = atomicAdd(garbage[0],1);
            // garbage[index + 2] = id;
            p.live = 0;
            p.next = p.prev = -1;
        }
        particles[id] = p;
    }else if(particles[id].live == 0 && stage == 3){
        int emitId = atomicAdd(atomicCounters[emittedCounter],-1);
        if(emitId > 0){
            _emission e = emitted[emitId - 1];
            initParticle(e, id);
        }
        
    }
    // barrier();
    // if(localID == 0){
    //     garbage[1] = atomicAdd(atomicCounters[liveParticles], -garbage[0]);
    // }
    // barrier();
    // if(localID < garbage[0]){
    //     dead[localID + garbage[1] - garbage[0]] = garbage[localID + 2];
    // }
    // barrier();

}

void initEmitters(uint id){
    emitterInit ei = emittersInits[id];
    emitter e;
    e.emitter_prototype = ei.emitterProtoID;
    e.transform = ei.transformID;
    e.live = ei.live;
    e.frame = 0;
    e.emission = 1;//prototypes[e.emitter_prototype].emission_rate * deltaTime;
    e.last = -1;
    emitters[ei.id] = e;
}


void emit(uint thread_id){
    // live[0] = 1;
    
    emitter e = emitters[thread_id];
    if(e.live == 1){

        emitter_prototype ep = prototypes[e.emitter_prototype];
        e.emission += ep.emission_rate * deltaTime;
        e.frame++;
        int emission = int(e.emission);
        
        int new_particles_start = atomicAdd(atomicCounters[emittedCounter],emission);
        int end = new_particles_start + emission;
        float dt = deltaTime;
        dt /= float(emission + 1);
        float count = 0.0;
        for(int i = new_particles_start; i < end && i < max_particles; ++i){
            emitted[i].position = transforms[e.transform].position;
            emitted[i].emitterID = int(thread_id);
            emitted[i].emitter_prototype = e.emitter_prototype;
            emitted[i].last = e.last;
            // int x = int(dead[i]);
            // particle p;
            // p.position = transforms[e.transform].position;
            // vec2 id = vec2(thread_id % max_particles, thread_id / max_particles);
            // p.rotation = normalize(vec4(
            // rand(id,time + 3 + count) - 0.5f,
            // rand(id,time + 4 + count) - 0.5f,
            // rand(id,time + 5 + count) - 0.5f,
            // rand(id,time + 6 + count) - 0.5f
            // ));
            // // p.rotation  = transforms[e.transform].rotation;
            // p.scale = transforms[e.transform].scale * ep.scale;
            // p.life = 1.f;
            // p.emitter = thread_id;
            // p.emitter_prototype = e.emitter_prototype;
            // vec3 random = vec3(
            // rand(id,time) - 0.5f,
            // rand(id,time + 1 + count) - 0.5f,
            // rand(id,time + 2 + count) - 0.5f);
            // p.velocity = vec3(rotate(identity(),transforms[e.transform].rotation) * vec4(random * ep.velocity * transforms[e.transform].scale,1));
            
            // p.position += p.velocity * dt * count;
            // p.life -= dt * count++ / prototypes[p.emitter_prototype].lifetime;
            // // set trail
            // if(ep.trail == 1){
            //     if(e.frame > 0){
            //         particles[e.last].next = int(x);
            //         particles[e.last].position2 = p.position;
            //         particles[e.last].velocity2 = p.velocity;
            //         particles[e.last].life2 = p.life;
            //     }
            //     p.next = -int(thread_id) - 2;
            //     p.prev = e.last;
            //     e.last = int(x);
            // }

            // p.live = 1;
            // particles[x] = p;
        }
        e.emission -= float(uint(e.emission));
    }else{
        e.frame = 0;
        e.last = -1;
    }
    emitters[thread_id] = e;

}

// void cleanup(uint thread_id){

//     uint liveMoved = atomicAdd(atomicCounters[liveParticles],-1);
//     uint toDestroyIndex = atomicAdd(atomicCounters[destroyCounter],-1);
//     // live[toDestroy[thread_id]] = particles[liveMoved];
//     dead[liveMoved - 1] = live[toDestroy[toDestroyIndex - 1]];
//     live[toDestroy[toDestroyIndex - 1]] = live[liveMoved - 1];
// }

layout( local_size_x = 128,  local_size_y = 1, local_size_z = 1) in;
void main () {
    uint gid = gl_GlobalInvocationID.x;
    if(stage == 2 && gid < count)
        initEmitters(gid);
    if( stage == 0 && gid < count) // only emitters
        emit(gid);
    if(stage == 1 && gid < max_particles){
        float dt = deltaTime;
        update(gid, dt);
    }
    if(stage == 3 && gid < max_particles){
        float dt = deltaTime;
        update(gid, dt);
    }
}