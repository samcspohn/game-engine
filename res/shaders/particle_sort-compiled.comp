#version 430 core
#define GLSLIFY 1
#define GLSLIFY 1
mat4 translate(mat4 m, vec3 translation){
		mat4 t = {{1,0,0,translation.x},
		{0,1,0,translation.y,},
		{0,0,1,translation.z}
		,{0,0,0,1}};
		return m * transpose(t);
}
mat4 scale(mat4 m, vec3 scale){
	mat4 s = {{scale.x,0,0,0}, {0,scale.y,0,0},{0,0,scale.z,0},{0,0,0,1}};
	return m * transpose(s);
}

mat4 rotate(mat4 m, vec4 q){
	mat4 r1 = {{q.w,q.z,-q.y,q.x},{-q.z,q.w,q.x,q.y},{q.y,-q.x,q.w,q.z},{-q.x,-q.y,-q.z,q.w}};
	mat4 r2 = {{q.w,q.z,-q.y,-q.x},{-q.z,q.w,q.x,-q.y},{q.y,-q.x,q.w,-q.z},{q.x,q.y,q.z,q.w}};
	mat4 r = r1 * r2;
	r[0][3] = r[1][3] = r[2][3] = r[3][0] = r[3][1] = r[3][2] = 0;
	r[3][3] = 1;
	return m * r;
}

mat4 identity(){
	mat4 i = {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}};
	return i;
}
vec4 lookAt(in vec3 lookAt, in vec3 up) {
vec3 forward = lookAt;
forward = normalize(forward);
vec3 right = normalize(cross(up, forward));
up = normalize(cross(forward,right));

#define m00 right.x
#define m01 up.x
#define m02 forward.x
#define m10 right.y
#define m11 up.y
#define m12 forward.y
#define m20 right.z
#define m21 up.z
#define m22 forward.z

vec4 ret;
ret.w = sqrt(1.0f + m00 + m11 + m22) * 0.5f;
float w4_recip = 1.0f / (4.0f * ret.w);
ret.x = (m21 - m12) * w4_recip;
ret.y = (m02 - m20) * w4_recip;
ret.z = (m10 - m01) * w4_recip;

#undef m00
#undef m01
#undef m02
#undef m10
#undef m11
#undef m12
#undef m20
#undef m21
#undef m22
return ret;
}

mat4 rotationMatrix(vec3 axis, float angle)
{
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;
    
    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                0.0,                                0.0,                                0.0,                                1.0);
}

vec3 rotate(vec3 axis, float angle, vec3 vec){
	if(angle == 0){
		return vec;
	}
	return (rotationMatrix(axis, angle) * vec4(vec,1)).xyz;
}

const uint RIGHT = 0x0000ffff;
const uint LEFT = 0xffff0000;
uint getLeft(uint field) {
	return field >> 16; // >>> operator 0-fills from left
}
uint getRight(uint field) {
	return field & RIGHT;
}

void setHighBits(inout uint o, uint left){
	o = (left << 16) | (o & RIGHT);
}
void setLowBits(inout uint o, uint right){
	o = (o & LEFT) | (right);
}
uint getHighBits(inout uint o){
	return getLeft(o);
}
uint getLowBits(inout uint o){
	return getRight(o);
}

#define M_PI 3.1415926535897932384626433832795
float PHI = 1.61803398874989484820459;  // Î¦ = Golden Ratio   
float rand(in vec2 xy, in float seed){
    xy += vec2(1);
    return fract(tan(distance(xy*PHI, xy)*sin(seed))*xy.x);
}
struct rng{
	vec2 r;
	float s;
	// void setSeed(vec2 rin, float seedin){
	// 	r = rin;
	// 	s = seedin;
	// }
	
	// float gen(){
	// 	float ret = rand(r, s);
	// 	r = r + vec2(1.21212121,2.12121212);
	// 	s += 2.121212112f;
	// 	return ret;
	// }
};
void setSeed(inout rng g, vec2 rin, float seedin){
	g.r = rin;
	g.s = seedin;
}

float gen(inout rng g){
	float ret = rand(g.r, g.s);
	g.r = g.r + vec2(1.21212121,2.12121212);
	g.s += 2.121212112f;
	return ret;
}
vec4 randVec4(inout rng g){
	return vec4(
    gen(g) - 0.5f,
    gen(g) - 0.5f,
    gen(g) - 0.5f,
    gen(g) - 0.5f
    );
}
vec3 randVec3(inout rng g){
	return vec3(
    gen(g) - 0.5f,
    gen(g) - 0.5f,
    gen(g) - 0.5f
    );
}
#define GLSLIFY 1
struct _transform {
	vec3 position; int id;
	vec3 scale; int parent;
	vec4 rotation;
	int childrenBegin;
	int childrenEnd;
	int prevSibling;
	int nextSibling;
};
#define GLSLIFY 1
struct particle{
    vec3 position;
    uint emitter;
    vec3 scale;
    uint emitter_prototype;
    vec4 rotation;

    vec3 velocity;
    int live;

    float life;
    int next;
    int prev;
    float life2;
    
    vec3 position2;
    int visible;
    vec3 velocity2;
    float l;
};
struct emitter_prototype{
    float emission_rate;
    float lifetime;
    float rotation_rate;
    float dispersion;

    // vec4 color;

    float minSpeed;
    float maxSpeed;
    float lifetime2;
    int live;

    vec3 scale;
    int billboard;

    int velAlign;
    float radius;
    int p2;
    int trail;
    vec4 colorLife[100];
    float sizeLife[100];
};
struct emitter{
    uint transform;
    uint emitter_prototype;
    float emission;
    int live;

    vec2 p;
    int last;
    int frame;
};

struct emitterInit{
    uint transformID;
    uint emitterProtoID;
    int live;
    int id;
}; 

struct d{
    // vec4 rot;
	uint xy;
    float z;
    uint qxy;
    uint qzw;
	// uint qwx;
    // uint qyz;
	uint scale_xy;
	uint protoID_life;
	// uint key_life;
};

uint getX(inout d item){
    return getHighBits(item.xy);
}
void setX(inout d item, uint x1){
    setHighBits(item.xy, x1);
}

uint getY(inout d item){ // 0x0000ffff
    return getLowBits(item.xy);
}
void setY(inout d item, uint y2){
    setLowBits(item.xy,y2);
}

void setZ(inout d item, float z){
    item.z = z;
    // item.z1 = (item.z & 0x0000ffff) | (floatBitsToUint(z) & 0xffff0000);
}
float getZ(inout d item){
    return item.z;
    // return uintBitsToFloat(item.z & 0xffff0000);
}
void setScale(inout d item, vec2 scale){
    item.scale_xy = (floatBitsToUint(scale.x) & LEFT) | (floatBitsToUint(scale.y) >> 16);
}
vec2 getScale(inout d item){
    return vec2(uintBitsToFloat(item.scale_xy & LEFT), uintBitsToFloat(getLowBits(item.scale_xy) << 16));
}

void setRotation(inout d item, vec4 quat){
    quat = normalize(quat);
    // setHighBits(item.qwx,uint(quat.w * 32768 + 32768));
    // setLowBits(item.qwx,uint(quat.x * 32768 + 32768));
    // setHighBits(item.qyz,uint(quat.y * 32768 + 32768));
    // setLowBits(item.qyz,uint(quat.z * 32768 + 32768));

    setHighBits(item.qxy,uint(quat.x * 32768 + 32768));
    setLowBits(item.qxy,uint(quat.y * 32768 + 32768));
    setHighBits(item.qzw,uint(quat.z * 32768 + 32768));
    setLowBits(item.qzw,uint(quat.w * 32768 + 32768));
    // item.rot = quat;
}

vec4 getRotation(inout d item){
    // return item.rot;
    return normalize(vec4((float(getHighBits(item.qxy)) - 32768) / 32768,
                (float(getLowBits(item.qxy)) - 32768) / 32768,
                (float(getHighBits(item.qzw)) - 32768) / 32768,
                (float(getLowBits(item.qzw)) - 32768) / 32768));
    // return normalize(vec4((float(getHighBits(item.qwx)) - 32768) / 32768,
    //         (float(getLowBits(item.qwx)) - 32768) / 32768,
    //         (float(getHighBits(item.qyz)) - 32768) / 32768,
    //         (float(getLowBits(item.qyz)) - 32768) / 32768));
}

uint protoID(inout d item){
    return item.protoID_life >> 16;
}
void protoID(inout d item, uint id){
    item.protoID_life = (item.protoID_life & uint(0x0000ffff)) | (id << 16);
}
// uint key(inout d item){
//     return item.key_life >> 16;
// }
// void key(inout d item, uint id){
//     item.key_life = (item.key_life & 0x0000ffff) | (id << 16);
// }
float life(inout d item){
    return uintBitsToFloat((item.protoID_life & uint(0x0000ffff)) << 16);
}
void life(inout d item, float l){
    item.protoID_life = (item.protoID_life & uint(0xffff0000)) | (floatBitsToUint(l) >> 16);
}

const uint WG_SIZE = 128;
const uint N_GROUPS = 256;
const uint RADIX = 12;
const uint BUCK = 1 << RADIX;
// const uint block_sum_size = uint(sqrt(N_GROUPS * BUCK));
const uint block_sum_size = 256;

layout(std430,binding = 0) buffer t{_transform transforms[];};
// layout(std430,binding = 13) buffer rp{uint renderParticles[];};
layout(std430,binding = 1) buffer d_in{d _input[];};
layout(std430,binding = 2) buffer d_out{d _output[];};
layout(std430,binding = 11) buffer ki{uint keys_in[];};
layout(std430,binding = 12) buffer ko{uint keys_out[];};
layout(std430,binding = 3) buffer blk_sum{uint block_sums[];};
layout(std430,binding = 4) buffer p{particle particles[];};
layout(std430,binding = 5) buffer a{uint atomics[];};
layout(std430,binding = 6) buffer d_s{uint scan[];};
layout(std430,binding = 7) buffer d_h{uint histo[];};
layout(std430,binding = 9) buffer ep{emitter_prototype prototypes[];};
layout(std430,binding = 10) buffer e{emitter emitters[];};
uniform int stage;
uniform mat4 vp;
uniform mat4 view;
uniform mat3 camInv;
uniform vec3 camp;
uniform uint count;
uniform float x_size;
uniform float y_size;
// uniform mat4 frustum;
uniform uint numElements;
uniform uint breadth;
//////////////////////////////////////////////////

// shared uint local_histo[BUCK];
// shared uint local_scan[BUCK*N_GROUPS];

uniform uint nkeys;
uniform uint pass;
uniform uint wg_size;
uniform uint offset;

uniform vec3 camPos;
uniform vec3 cameraForward;
uniform vec3 cameraUp;

shared uint _keys[4096];
shared uint buckets[2048]; // 12 bits
shared uint ids[4096];
shared uint local_sums[128];

void subSort(uint g_id){
    
    // 4096 / 128 = 32
    uint l_id = gl_LocalInvocationID.x;
    uint w_id = gl_WorkGroupID.x;
    uint start = l_id * 32;
    uint end = start + 32;

    uint buckStart = l_id * 16;
    uint buckEnd = buckStart + 16;

    uint globalOffset = 4096 * w_id;
    for(uint i = buckStart; i < buckEnd; ++i){
        buckets[i] = 0;
    }

barrier();
    if(end + globalOffset > nkeys){
        end = nkeys - globalOffset;
    }
    for(uint i = start; i < end; ++i){
        // uint k = key(_output[globalOffset + i]);
        uint k = keys_out[globalOffset + i];
        k >>= 5;
        _keys[i] = k;
        ids[i] = globalOffset + i;
        atomicAdd(buckets[k],1);
    }
barrier();

    uint temp = buckets[buckStart];
    buckets[buckStart] = 0;
    for(uint i = buckStart + 1; i < buckEnd; i++){
        uint temp2 = buckets[i];
        buckets[i] = temp;
        temp += temp2;
    }
    local_sums[l_id] = temp;
barrier();
    if(l_id == 0){
        uint temp = globalOffset +  local_sums[0];
        local_sums[0] = globalOffset;
        for(uint i = 1; i < 128; i++){
            uint temp2 = local_sums[i];
            local_sums[i] = temp;
            temp += temp2;
        }
    }
barrier();
    for(uint i = buckStart; i < buckEnd; ++i){
        // uint group_id = gl_WorkGroupID.x;
        buckets[i] += local_sums[l_id];
    }
barrier();

    for(uint i = start; i < end; ++i){
        uint index = atomicAdd(buckets[_keys[i]],1);
        _input[index] = _output[ids[i]];
        keys_in[index] = keys_out[ids[i]];

    }
}

void radix(uint g_id){
    uint index;
    // first pass
    if(stage == 0){
        subSort(g_id);
    }

    if(stage == 1){
        uint start = g_id * block_sum_size;
        uint end = start + block_sum_size;
        
        uint temp = histo[start];
        histo[start] = 0;
        for(uint i = start + 1; i < end; i++){
            uint temp2 = histo[i];
            histo[i] = temp;
            temp += temp2;
        }
        block_sums[g_id] = temp;
    }

    if(stage == 2){
        uint temp = block_sums[0];
        block_sums[0] = 0;
        for(uint i = 1; i < block_sum_size; i++){
            uint temp2 = block_sums[i];
            block_sums[i] = temp;
            temp += temp2;
        }
    }

    if(stage == 3){
        // uint group_id = gl_WorkGroupID.x;
        histo[g_id] += block_sums[g_id/block_sum_size];
    }
    else if(stage == 4){
        d item = _input[g_id]; 
        // index = key(item);
        index = keys_in[g_id]; 
        _output[atomicAdd(histo[index],1)] = item;
        // uint off = count / 128;
        // _output[(gl_LocalInvocationID.x * off + gl_WorkGroupID.x) % count] = item;
    }

    // // second pass
    // else if(stage == 3){
    //     index = data2[gid].key >> 16;
    //     atomicAdd(counts[index],1);
    // }
    // else if(gid == 0 && stage == 4){
    //     offsets[0] = 0;
    //     for(int i = 1; i < 65536; i++){
    //         offsets[i] = offsets[i - 1] + counts[i - 1];
    //     }
    // }else if(stage == 5){
    //     index = data2[gid].key >> 16;
    //     data1[atomics[0] - atomicAdd(offsets[index],1)] = data2[gid];
    // }
}

uint convertFloatToClamped(float f){
    return uint(f * 32768 + 32768);
}
uint getAngle(vec3 a, vec3 b,vec2 quadrant){
    float angle = acos(dot(normalize(a),normalize(b)));
    if(quadrant.x > 0){
        angle = 6.28318530718 - angle;
    }
    return uint((angle / 6.28318530718) * 65536);
}
void rotateX(inout vec3 vec, float angle){
    float y = vec.y;
    float z = vec.z;
    vec.y = y * cos(angle) - z * sin(angle);
    vec.z = y * sin(angle) + z * cos(angle);
}

void genPosition1(inout d item, vec3 a){
    vec3 newVec = vec3(a.x,a.y,-a.z);
    uint xAxisAngle = getAngle(newVec,vec3(a.x,0,-a.z),vec2(a.y,a.z));
    // rotateX(newVec,-xAxisAngle);
    setX(item, xAxisAngle);
    uint yAxisAngle = getAngle(vec3(a.x,0, -a.z), vec3(0,0, 1),vec2(a.x,a.z));
    setY(item, yAxisAngle);
    setZ(item, -length(a));
}

// void makeRenderParticle(uint index){

//     uint id = renderParticles[index];
//     particle p = particles[id];
//     emitter_prototype proto = prototypes[p.emitter_prototype];
//     vec3 p1 = (vp * vec4(p.position,1)).xyz;
//     vec3 p2 = (vp * vec4(p.position2,1)).xyz;
//     d item;
//     uint _key =  (~floatBitsToUint(p1.z) << 1) >> 16;
//     // key(item, _key);
//     keys_out[index] = _key;
//     // emitterID(item, p.emitter);
//     life(item, p.life);
//     protoID(item, p.emitter_prototype);
//     vec3 p11;
//     vec3 p21;
//     vec4 rot;
//     vec2 _scale;
//     if(prototypes[p.emitter_prototype].trail == 1){
//         p11 = p.position;
//         p21 = p.position2;
//         p11 = p11 + (p21 - p11) / 2;
//         _scale = vec2(p.scale.x, length(p.position - p.position2));
//     }else{
//         _scale = p.scale.xy;
//         p11 = p.position;
//     }
//     rot = p.rotation;
//     if(proto.billboard == 1)
//         rot = lookAt(-cameraForward, (cameraForward == vec3(0,0,1) || cameraForward == vec3(0,0,-1)) ? vec3(1,0,0) : cameraUp) * proto.billboard;
//     if(proto.trail == 1){
//         // p.rotation = lookAt(-cameraForward, (cameraForward == vec3(0,0,1) || cameraForward == vec3(0,0,-1)) ? vec3(1,0,0) : cameraUp);
//         vec3 y = p.position2 - p.position;
//         vec3 x = cross(y, p.position2 - camPos);
//         vec3 l = cross(x,y);
//         rot = lookAt(l,y);
//     }
//     p11 -= camPos;
//     setScale(item,_scale);
//     genPosition1(item, p11);
//     setRotation(item, rot);
//     // genPosition2(item, p21);

//     // item.id = gid;
//     atomicAdd(histo[_key],1);
//     // _input[index] = item;
//     _output[index] = item;
// }

layout( local_size_x = 128,  local_size_y = 1, local_size_z = 1) in;
void main () {
    uint gid = gl_GlobalInvocationID.x;
    uint index;
    if(gid < count){
        switch(stage){
            case -2:
                histo[gid] = 0;
                break;
            case -1:
                {
                    particle p = particles[gid];
                    emitter_prototype proto = prototypes[p.emitter_prototype];
                    vec3 p1 = camInv * (p.position - camp);
                    vec3 p2 = camInv * (p.position2 - camp);
                    vec3 p3 = (p1 + p2) / 2;
                    float radius = length(p2 - p3) / 2 + 
                    prototypes[p.emitter_prototype].sizeLife[int((1.f - min(max(p.life,0.01f),1.f)) * 100.f)] * length(p.scale.xy);
                    if(p.live == 1 && p3.z - radius < 0.f
                    && (abs(p3.x) - radius) / abs(p3.z) < x_size
                    && (abs(p3.y) - radius) / abs(p3.z) < y_size){
                        // && (abs(p3.x) - radius) / abs(p3.z) < 1.f && (abs(p3.y) - radius) / abs(p3.z) < 1.f){
                        index = atomicAdd(atomics[0],1);
                        // renderParticles[index] = gid;
                        d item;
                        uint _key =  (~floatBitsToUint(p1.z) << 1) >> 16;
                        // key(item, _key);
                        keys_out[index] = _key;
                        // emitterID(item, p.emitter);
                        life(item, p.life);
                        protoID(item, p.emitter_prototype);
                        vec3 p11;
                        vec3 p21;
                        vec4 rot;
                        vec2 _scale;
                        rot = p.rotation;
                        if(prototypes[p.emitter_prototype].trail == 1){
                            p11 = p.position;
                            p21 = p.position2;
                            p11 = p11 + (p21 - p11) / 2;
                            _scale = vec2(p.scale.x, length(p.position - p.position2));
                        }else{
                            _scale = p.scale.xy;
                            p11 = p.position;
                        }
                        if(proto.billboard == 1)
                            rot = lookAt(-cameraForward, (cameraForward == vec3(0,0,1) || cameraForward == vec3(0,0,-1)) ? vec3(1,0,0) : cameraUp) * proto.billboard;
                        if(proto.trail == 1){
                            // p.rotation = lookAt(-cameraForward, (cameraForward == vec3(0,0,1) || cameraForward == vec3(0,0,-1)) ? vec3(1,0,0) : cameraUp);
                            vec3 y = p.position2 - p.position;
                            vec3 x = cross(y, p.position2 - camPos);
                            vec3 l = cross(x,y);
                            rot = lookAt(l,y);
                        }
                        p11 -= camPos;
                        setScale(item,_scale);
                        genPosition1(item, p11);
                        setRotation(item, rot);
                        // genPosition2(item, p21);

                        // item.id = gid;
                        atomicAdd(histo[_key],1);
                        // _input[index] = item;
                        _output[index] = item;
                        // _input[index].id = gid;
                    }
                }
                break;
            // case -3:
            //     makeRenderParticle(gid);
            //     break;
            default:
                radix(gid);
                break;
        }
    }
}